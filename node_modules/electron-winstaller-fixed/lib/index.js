'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWindowsInstaller = undefined;

var _bluebird = require('bluebird');

let copyUpdateExe = (() => {
  var ref = (0, _bluebird.coroutine)(function* (destination, options) {
    yield (0, _fsExtraP.copy)(vendor('Update.exe'), destination);
    if (options.sign != null) {
      yield options.sign(destination);
    }
  });
  return function copyUpdateExe(_x, _x2) {
    return ref.apply(this, arguments);
  };
})();

let createWindowsInstaller = exports.createWindowsInstaller = (() => {
  var ref = (0, _bluebird.coroutine)(function* (options) {
    const stageDir = _path2.default.join((0, _os.tmpdir)(), getTempName('squirrel-windows-builder'));
    yield (0, _fsExtraP.emptyDir)(stageDir);
    try {
      yield build(options, stageDir);
    } finally {
      try {
        yield (0, _fsExtraP.remove)(stageDir);
      } catch (e) {
        // ignore
      }
    }
  });
  return function createWindowsInstaller(_x3) {
    return ref.apply(this, arguments);
  };
})();

let build = (() => {
  var ref = (0, _bluebird.coroutine)(function* (options, stageDir) {
    const metadata = options;
    const appUpdate = _path2.default.join(stageDir, 'Update.exe');
    const outputDirectory = _path2.default.resolve(options.outputDirectory || 'installer');
    const promises = [copyUpdateExe(appUpdate, options), (0, _fsExtraP.emptyDir)(outputDirectory)];
    if (options.remoteReleases) {
      promises.push(syncReleases(outputDirectory, options));
    }
    yield _bluebird.Promise.all(promises);

    const embeddedArchiveFile = _path2.default.join(stageDir, 'setup.zip');
    const embeddedArchive = (0, _archiver2.default)('zip');
    const embeddedArchiveOut = (0, _fsExtraP.createWriteStream)(embeddedArchiveFile);
    const embeddedArchivePromise = new _bluebird.Promise(function (resolve, reject) {
      embeddedArchive.on('error', reject);
      embeddedArchiveOut.on('close', resolve);
    });
    embeddedArchive.pipe(embeddedArchiveOut);

    embeddedArchive.file(appUpdate, { name: 'Update.exe' });
    embeddedArchive.file(options.loadingGif ? _path2.default.resolve(options.loadingGif) : _path2.default.join(__dirname, '..', 'resources', 'install-spinner.gif'), { name: 'background.gif' });

    const version = convertVersion(metadata.version);
    const packageName = `${ metadata.name }-${ version }-full.nupkg`;
    const nupkgPath = _path2.default.join(outputDirectory, packageName);
    const setupPath = _path2.default.join(outputDirectory, options.setupExe || `${ metadata.name || metadata.productName }Setup.exe`);

    yield _bluebird.Promise.all([pack(metadata, options.appDirectory, appUpdate, nupkgPath, version, options.packageCompressionLevel), (0, _fsExtraP.copy)(vendor('Setup.exe'), setupPath)]);

    embeddedArchive.file(nupkgPath, { name: packageName });

    const releaseEntry = yield releasify(nupkgPath, outputDirectory, packageName);

    embeddedArchive.append(releaseEntry, { name: 'RELEASES' });
    embeddedArchive.finalize();
    yield embeddedArchivePromise;

    yield writeZipToSetup(setupPath, embeddedArchiveFile);
    if (options.sign != null) {
      yield options.sign(setupPath);
    }
    if (options.msi && process.platform === 'win32') {
      const outFile = options.msiExe || `${ metadata.productName || metadata.name }Setup.msi`;
      yield msi(nupkgPath, setupPath, outputDirectory, outFile);
      if (options.sign != null) {
        yield options.sign(_path2.default.join(outputDirectory, outFile));
      }
    }
  });
  return function build(_x4, _x5) {
    return ref.apply(this, arguments);
  };
})();

let pack = (() => {
  var ref = (0, _bluebird.coroutine)(function* (metadata, directory, updateFile, outFile, version, packageCompressionLevel) {
    const archive = (0, _archiver2.default)('zip', { zlib: { level: packageCompressionLevel == null ? 9 : packageCompressionLevel } });
    // const archiveOut = createWriteStream('/Users/develar/test.zip')
    const archiveOut = (0, _fsExtraP.createWriteStream)(outFile);
    const archivePromise = new _bluebird.Promise(function (resolve, reject) {
      archive.on('error', reject);
      archiveOut.on('close', resolve);
    });
    archive.pipe(archiveOut);

    const author = metadata.authors || metadata.owners;
    const copyright = metadata.copyright || `Copyright Â© ${ new Date().getFullYear() } ${ author }`;
    const nuspecContent = `<?xml version="1.0"?>
<package xmlns="http://schemas.microsoft.com/packaging/2011/08/nuspec.xsd">
  <metadata>
    <id>${ metadata.name }</id>
    <version>${ version }</version>
    <title>${ metadata.title }</title>
    <authors>${ author }</authors>
    <owners>${ metadata.owners || metadata.authors }</owners>
    <iconUrl>${ metadata.iconUrl }</iconUrl>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <description>${ metadata.description }</description>
    <copyright>${ copyright }</copyright>${ metadata.extraMetadataSpecs || '' }
  </metadata>
</package>`;
    log(`Created NuSpec file:\n${ nuspecContent }`);
    archive.append(nuspecContent.replace(/\n/, '\r\n'), { name: `${ encodeURI(metadata.name).replace(/%5B/g, '[').replace(/%5D/g, ']') }.nuspec` });

    archive.append(`<?xml version="1.0" encoding="utf-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Type="http://schemas.microsoft.com/packaging/2010/07/manifest" Target="/${ metadata.name }.nuspec" Id="Re0" />
  <Relationship Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="/package/services/metadata/core-properties/1.psmdcp" Id="Re1" />
</Relationships>`.replace(/\n/, '\r\n'), { name: '.rels', prefix: '_rels' });

    archive.append(`<?xml version="1.0" encoding="utf-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="nuspec" ContentType="application/octet" />
  <Default Extension="pak" ContentType="application/octet" />
  <Default Extension="asar" ContentType="application/octet" />
  <Default Extension="bin" ContentType="application/octet" />
  <Default Extension="dll" ContentType="application/octet" />
  <Default Extension="exe" ContentType="application/octet" />
  <Default Extension="dat" ContentType="application/octet" />
  <Default Extension="psmdcp" ContentType="application/vnd.openxmlformats-package.core-properties+xml" />
  <Override PartName="/lib/net45/LICENSE" ContentType="application/octet" />
  <Default Extension="diff" ContentType="application/octet" />
  <Default Extension="bsdiff" ContentType="application/octet" />
  <Default Extension="shasum" ContentType="text/plain" />
</Types>`.replace(/\n/, '\r\n'), { name: '[Content_Types].xml' });

    archive.append(`<?xml version="1.0" encoding="utf-8"?>
<coreProperties xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns="http://schemas.openxmlformats.org/package/2006/metadata/core-properties">
  <dc:creator>${ author }</dc:creator>
  <dc:description>${ metadata.description }</dc:description>
  <dc:identifier>${ metadata.name }</dc:identifier>
  <version>${ version }</version>
  <keywords/>
  <dc:title>${ metadata.title }</dc:title>
  <lastModifiedBy>NuGet, Version=2.8.50926.602, Culture=neutral, PublicKeyToken=null;Microsoft Windows NT 6.2.9200.0;.NET Framework 4</lastModifiedBy>
</coreProperties>`.replace(/\n/, '\r\n'), { name: '1.psmdcp', prefix: 'package/services/metadata/core-properties' });

    archive.file(updateFile, { name: 'Update.exe', prefix: 'lib/net45' });
    encodedZip(archive, directory, 'lib/net45');
    yield archivePromise;
  });
  return function pack(_x6, _x7, _x8, _x9, _x10, _x11) {
    return ref.apply(this, arguments);
  };
})();

let releasify = (() => {
  var ref = (0, _bluebird.coroutine)(function* (nupkgPath, outputDirectory, packageName) {
    const args = ['--releasify', nupkgPath, '--releaseDir', outputDirectory];
    const out = (yield (0, _spawnPromise.exec)(process.platform === 'win32' ? vendor('Update.com') : 'mono', prepareArgs(args, vendor('Update-Mono.exe')))).trim();
    if (log.enabled) {
      log(out);
    }

    const lines = out.split('\n');
    for (let i = lines.length - 1; i > -1; i--) {
      const line = lines[i];
      if (line.indexOf(packageName) != -1) {
        return line.trim();
      }
    }

    throw new Error('Invalid output, cannot find last release entry');
  });
  return function releasify(_x12, _x13, _x14) {
    return ref.apply(this, arguments);
  };
})();

let msi = (() => {
  var ref = (0, _bluebird.coroutine)(function* (nupkgPath, setupPath, outputDirectory, outFile) {
    const args = ['--createMsi', nupkgPath, '--bootstrapperExe', setupPath];
    yield (0, _spawnPromise.exec)(process.platform === 'win32' ? vendor('Update.com') : 'mono', prepareArgs(args, vendor('Update-Mono.exe')));
    yield (0, _spawnPromise.exec)(vendor('candle.exe'), ['-nologo', '-ext', 'WixNetFxExtension', '-out', 'Setup.wixobj', 'Setup.wxs'], {
      cwd: outputDirectory
    });
    yield (0, _spawnPromise.exec)(vendor('light.exe'), ['-ext', 'WixNetFxExtension', '-sval', '-out', outFile, 'Setup.wixobj'], {
      cwd: outputDirectory
    });

    //noinspection SpellCheckingInspection
    yield _bluebird.Promise.all([(0, _fsExtraP.unlink)(_path2.default.join(outputDirectory, 'Setup.wxs')), (0, _fsExtraP.unlink)(_path2.default.join(outputDirectory, 'Setup.wixobj')), (0, _fsExtraP.unlink)(_path2.default.join(outputDirectory, outFile.replace('.msi', '.wixpdb'))).catch(function (e) {
      return log(e.toString());
    })]);
  });
  return function msi(_x15, _x16, _x17, _x18) {
    return ref.apply(this, arguments);
  };
})();

exports.convertVersion = convertVersion;
exports.getTempName = getTempName;

var _spawnPromise = require('./spawn-promise');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _archiver = require('archiver');

var _archiver2 = _interopRequireDefault(_archiver);

var _fsExtraP = require('fs-extra-p');

var _archiverUtils = require('archiver-utils');

var _archiverUtils2 = _interopRequireDefault(_archiverUtils);

var _os = require('os');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = require('debug')('electron-windows-installer');

function convertVersion(version) {
  const parts = version.split('-');
  const mainVersion = parts.shift();

  if (parts.length > 0) {
    return [mainVersion, parts.join('-').replace(/\./g, '')].join('-');
  } else {
    return mainVersion;
  }
}

function syncReleases(outputDirectory, options) {
  const args = prepareArgs(['-u', options.remoteReleases, '-r', outputDirectory], vendor('SyncReleases.exe'));
  if (options.remoteToken) {
    args.push('-t', options.remoteToken);
  }
  return (0, _spawnPromise.spawn)(process.platform === 'win32' ? vendor('SyncReleases.exe') : 'mono', args);
}

function writeZipToSetup(setupExe, zipFile) {
  const exePath = vendor('WriteZipToSetup.exe');
  return (0, _spawnPromise.exec)(process.platform === 'win32' ? exePath : 'wine', prepareArgs([setupExe, zipFile], exePath));
}

function prepareArgs(args, exePath) {
  if (process.platform !== 'win32') {
    args.unshift(exePath);
  }
  return args;
}

function vendor(executable) {
  return _path2.default.join(__dirname, '..', 'vendor', executable);
}

function encodedZip(archive, dir, prefix) {
  _archiverUtils2.default.walkdir(dir, function (error, files) {
    if (error) {
      archive.emit('error', error);
      return;
    }

    for (let file of files) {
      if (file.stats.isDirectory()) {
        continue;
      }

      // GBK file name encoding (or Non-English file name) caused a problem
      const entryData = {
        name: encodeURI(file.relative.replace(/\\/g, '/')).replace(/%5B/g, '[').replace(/%5D/g, ']'),
        prefix: prefix,
        stats: file.stats
      };
      archive._append(file.path, entryData);
    }

    archive.finalize();
  });
}

let tmpDirCounter = 0;
// add date to avoid use stale temp dir
const tempDirPrefix = `${ process.pid.toString(36) }-${ Date.now().toString(36) }`;

function getTempName(prefix) {
  return `${ prefix == null ? '' : prefix + '-' }${ tempDirPrefix }-${ (tmpDirCounter++).toString(36) }`;
}